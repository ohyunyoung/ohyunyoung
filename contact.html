<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>OHYUNYOUNG</title>
  <link rel="stylesheet" href="style.css?v=2" />
</head>
<body>
  <div class="container">
    <nav>
      <a href="contact.html">ì—°ë½</a>
      <a href="work.html">ì‘ì—…</a>
    </nav>

    <div class="speech-bubble">
      <p>ì•ˆë…•í•˜ì„¸ìš”. ì˜¤ìœ¤ì˜ì…ë‹ˆë‹¤.</p>
      <p>ë°©ë¬¸í•´ ì£¼ì…”ì„œ ê°ì‚¬í•©ë‹ˆë‹¤.</p>

      <button class="bubble-emoji-btn" type="button" aria-label="smile">â˜º</button>

      <div class="sticker-toast" aria-live="polite">on</div>
      <button class="clean-btn" type="button">ë¹„ìš°ê¸°</button>
    </div>

    <br />

    <div class="contact-info">
      <p>ì´ë©”ì¼: <a href="mailto:560arte@gmail.com">560arte@gmail.com</a></p>
      <p>ì¸ìŠ¤íƒ€: <a href="https://instagram.com/560_oo" target="_blank" rel="noopener">@560_oo</a></p>
    </div>
  </div>

 
<script>
(function () {
  const btn = document.querySelector(".bubble-emoji-btn");
  const bubble = document.querySelector(".speech-bubble");
  const toast = document.querySelector(".sticker-toast");
  const cleanBtn = document.querySelector(".clean-btn");
  if (!btn || !bubble) return;

  let clickCount = 0;
  let stickerMode = false;

  // ===== ìŠ¤í‹°ì»¤ í•©ì²´ ì„¤ì • =====
  const BASE_SIZE = 20;
  const GROW = 10;
  const MAX_LEVEL = 5;
  const RISE_Y = 70;
  const MERGE_DIST = 26;
  const MERGE_COOLDOWN_MS = 80;

  // ===== ì§€ë©´ =====
  const GROUND_PAD = 200;

  function groundYFor(el){
    const h = el.getBoundingClientRect().height || 0;
    return window.innerHeight - GROUND_PAD - h / 2;
  }
  function clampToGround(el, y){
    return Math.min(y, groundYFor(el));
  }
  function fallToGround(el){
    if (!el || !document.body.contains(el)) return;
    const gy = groundYFor(el);
    const cur = parseFloat(el.style.top) || 0;
    el.style.top = Math.min(cur, gy) + "px";
    requestAnimationFrame(() => {
      if (!document.body.contains(el)) return;
      el.style.top = gy + "px";
    });
  }
  window.addEventListener("resize", () => {
    document.querySelectorAll(".emoji-sticker.grounded").forEach(fallToGround);
  });

  const emojis = [
    "ğŸ€","âœ¨","ğŸ’›","ğŸŒ¿","ğŸ«§","â­","ğŸ’«","ğŸˆ","ğŸ¦•","ğŸ”¥","ğŸŒˆ","ğŸ†","ğŸ","ğŸ‰","ğŸ’•","ğŸ’¥","ğŸ’¡","ğŸ’£","â˜ƒï¸","ğŸ¿",
    "ğŸŒ™","ğŸŒ","â˜ï¸","ğŸŒ§ï¸","ğŸŒŠ","âš¡","ğŸ•Šï¸","ğŸ¾","ğŸ—¨ï¸","ğŸ§¡","ğŸ¤","ğŸ©¶","ğŸ’™","ğŸ’œ","ğŸ–¤"
  ];

  function showToast(ms = 1600) {
    if (!toast) return;
    toast.classList.remove("show");
    void toast.offsetWidth;
    toast.classList.add("show");
    setTimeout(() => toast.classList.remove("show"), ms);
  }

  function sizeForLevel(level){
    const base = BASE_SIZE + (level - 1) * GROW;
    if (level >= MAX_LEVEL) return base + 20; // ìµœì¢…ë§Œ +20
    return base;
  }

  function getCenter(el){
    const r = el.getBoundingClientRect();
    return { x: r.left + r.width/2, y: r.top + r.height/2 };
  }

  function bakeStickerPosition(el){
    const driftX = parseFloat(getComputedStyle(el).getPropertyValue("--drift-x")) || 0;
    const left = parseFloat(el.style.left) || 0;
    const top  = parseFloat(el.style.top)  || 0;

    el.style.left = (left + driftX) + "px";
    el.style.top  = (top  - RISE_Y) + "px";

    el.style.animation = "none";
    el.style.filter = "none";
    el.style.opacity = "1";
  }

  function makeStickerAt(x, y, emoji, level){
    const el = document.createElement("span");
    el.className = "emoji-pop emoji-sticker";
    el.textContent = emoji;
    el.dataset.level = String(level);

    const drift = (Math.random() * 30 - 15);
    el.style.setProperty("--drift-x", drift + "px");

    el.style.left = x + "px";
    el.style.top  = y + "px";
    el.style.fontSize = sizeForLevel(level) + "px";

    document.body.appendChild(el);

    el.addEventListener("animationend", () => {
      if (!document.body.contains(el)) return;
      bakeStickerPosition(el);
      setTimeout(() => tryMerge(el), MERGE_COOLDOWN_MS);
    }, { once: true });

    return el;
  }

  function makeGroundedAt(x, y, emoji, level){
    const el = document.createElement("span");
    el.className = "emoji-pop emoji-sticker grounded";
    el.textContent = emoji;
    el.dataset.level = String(level);
    el.dataset.grounded = "1";

    el.style.left = x + "px";
    el.style.top  = y + "px";
    el.style.fontSize = sizeForLevel(level) + "px";
    el.style.animation = "none";
    el.style.filter = "none";
    el.style.opacity = "1";

    document.body.appendChild(el);
    fallToGround(el);
    return el;
  }

  function tryMerge(target){
    if (!target || !target.classList.contains("emoji-sticker")) return;
    if (!document.body.contains(target)) return;
    if (target.dataset.grounded === "1") return;

    const emoji = (target.textContent || "").trim();
    const level = parseInt(target.dataset.level || "1", 10);
    const { x: tx, y: ty } = getCenter(target);

    let best = null;
    let bestD = Infinity;
    let bestLevel = 1;

    document.querySelectorAll(".emoji-sticker").forEach((el) => {
      if (el === target) return;
      if (!document.body.contains(el)) return;
      if (el.dataset.grounded === "1") return;
      if ((el.textContent || "").trim() !== emoji) return;

      const lv = parseInt(el.dataset.level || "1", 10);
      const c = getCenter(el);
      const d = Math.hypot(c.x - tx, c.y - ty);

      if (d < bestD) {
        bestD = d;
        best = el;
        bestLevel = lv;
      }
    });

    if (!best) return;

    const threshold = MERGE_DIST + (sizeForLevel(level) + sizeForLevel(bestLevel)) * 0.12;
    if (bestD > threshold) return;

    const c1 = getCenter(target);
    const c2 = getCenter(best);
    const mx = (c1.x + c2.x) / 2;
    const my = (c1.y + c2.y) / 2;

    target.remove();
    best.remove();

    const newLevel = Math.max(level, bestLevel) + 1;

    if (newLevel >= MAX_LEVEL) {
      makeGroundedAt(mx, my, emoji, newLevel);
      return;
    }

    makeStickerAt(mx, my, emoji, newLevel);
  }

  function spawnEmoji(isSticker){
    const rect = btn.getBoundingClientRect();

    const el = document.createElement("span");
    el.className = "emoji-pop " + (isSticker ? "emoji-sticker" : "emoji-float");
    el.textContent = emojis[Math.floor(Math.random() * emojis.length)];

    const drift = (Math.random() * 30 - 15);
    el.style.setProperty("--drift-x", drift + "px");

    const spread = stickerMode ? 120 : 0;
    const randX = (Math.random() * 2 - 1) * spread;
    const randY = (Math.random() * 2 - 1) * spread;

    let startX = rect.left + rect.width / 2 + randX;
    let startY = rect.top  + rect.height / 2 + randY;

    const margin = 20;
    startX = Math.max(margin, Math.min(window.innerWidth - margin, startX));
    startY = Math.max(margin, Math.min(window.innerHeight - margin, startY));

    el.style.left = startX + "px";
    el.style.top  = startY + "px";

    document.body.appendChild(el);

    if (!isSticker) {
      el.addEventListener("animationend", () => el.remove(), { once: true });
      return;
    }

    el.dataset.level = "1";
    el.style.fontSize = sizeForLevel(1) + "px";

    el.addEventListener("animationend", () => {
      if (!document.body.contains(el)) return;
      bakeStickerPosition(el);
      setTimeout(() => tryMerge(el), MERGE_COOLDOWN_MS);
    }, { once: true });
  }

  // í´ë¦­: 7ë²ˆì§¸ë¶€í„° ìŠ¤í‹°ì»¤ ëª¨ë“œ
  btn.addEventListener("click", () => {
    clickCount += 1;
    if (clickCount === 5) {
      stickerMode = true;
      bubble.classList.add("sticker-on");
      showToast(1600);
    }
    spawnEmoji(stickerMode);
  });


  // ===== ì”ìƒ =====
  const TRAIL_COUNT = 10;
  const trails = new Map(); // key: emoji element, value: {segs,pos,head}
  let trailsRaf = 0;

  function trailStart(el){
    if (!el || trails.has(el)) return;

    const emoji = (el.textContent || "").trim();
    const fs = el.style.fontSize || "20px";
    const x = parseFloat(el.style.left) || 0;
    const y = parseFloat(el.style.top)  || 0;

    const pos = Array.from({ length: TRAIL_COUNT }, () => ({ x, y }));
    const head = { x, y };
    const segs = [];

    for (let i = 0; i < TRAIL_COUNT; i++) {
      const s = document.createElement("span");
      s.className = "emoji-trail-seg";
      s.textContent = emoji;
      s.style.left = x + "px";
      s.style.top  = y + "px";
      s.style.fontSize = fs;

      const alpha = 0.55 * (1 - i / TRAIL_COUNT);
      s.style.opacity = String(alpha);
      s.style.filter = `blur(${0.2 + i * 0.12}px)`;

      document.body.appendChild(s);
      segs.push(s);
    }

    trails.set(el, { segs, pos, head });

    if (!trailsRaf) trailsRaf = requestAnimationFrame(stepAllTrails);
  }

  function trailUpdate(el, x, y){
    const st = trails.get(el);
    if (!st) return;
    st.head.x = x;
    st.head.y = y;
  }

  function trailStop(el){
    const st = trails.get(el);
    if (!st) return;
    st.segs.forEach(s => s.remove());
    trails.delete(el);

    if (trails.size === 0 && trailsRaf) {
      cancelAnimationFrame(trailsRaf);
      trailsRaf = 0;
    }
  }

  function trailStopAll(){
    Array.from(trails.keys()).forEach(trailStop);
  }

  function stepAllTrails(){
    trails.forEach((st, el) => {
      if (!document.body.contains(el)) {
        st.segs.forEach(s => s.remove());
        trails.delete(el);
        return;
      }

      // ì²« ì”ìƒì€ ì‹¤ë¬¼ê³¼ ê°™ì€ ìœ„ì¹˜
      st.pos[0].x = st.head.x;
      st.pos[0].y = st.head.y;

      // ë’¤ëŠ” ë”°ë¼ì˜¤ê²Œ
      for (let i = 1; i < TRAIL_COUNT; i++) {
        st.pos[i].x += (st.pos[i-1].x - st.pos[i].x) * 0.14;
        st.pos[i].y += (st.pos[i-1].y - st.pos[i].y) * 0.14;
      }

      for (let i = 0; i < st.segs.length; i++) {
        const s = st.segs[i];
        s.style.left = st.pos[i].x + "px";
        s.style.top  = st.pos[i].y + "px";
      }
    });

    if (trails.size > 0) {
      trailsRaf = requestAnimationFrame(stepAllTrails);
    } else {
      trailsRaf = 0;
    }
  }

  // ===== ë‚ ì•„ê°€ê¸° =====
  const GRAVITY = 2200;
  const BOUNCE = 0.72;
  const WALL_BOUNCE = 0.85;
  const AIR_FRICTION = 0.992;
  const STOP_V = 35;
  const MAX_SPEED = 2200;

  const flights = new Map(); // key: el, value: raf

  function stopFlight(el){
    const raf = flights.get(el);
    if (raf) cancelAnimationFrame(raf);
    flights.delete(el);
    if (el) el.classList.remove("flying");
  }

  function startFlight(el, vx, vy){
    if (!el || !document.body.contains(el)) return;

    stopFlight(el);
    trailStart(el); // ì´ëª¨ì§€ë§ˆë‹¤ ì”ìƒ ì‹œì‘

    vx = Math.max(-MAX_SPEED, Math.min(MAX_SPEED, vx));
    vy = Math.max(-MAX_SPEED, Math.min(MAX_SPEED, vy));

    el.classList.add("flying");

    let last = performance.now();

    const step = (now) => {
      if (!document.body.contains(el)) {
        trailStop(el);
        stopFlight(el);
        return;
      }

      const dt = Math.min(0.033, (now - last) / 1000);
      last = now;

      let x = parseFloat(el.style.left) || 0;
      let y = parseFloat(el.style.top)  || 0;

      vy += GRAVITY * dt;
      x += vx * dt;
      y += vy * dt;

      const w = el.getBoundingClientRect().width || 0;
      const h = el.getBoundingClientRect().height || 0;
      const pad = 10;

      const minX = pad + w/2;
      const maxX = window.innerWidth - pad - w/2;

      const minY = pad + h/2;
      const maxY = groundYFor(el);

      if (x <= minX) { x = minX; vx = -vx * WALL_BOUNCE; }
      if (x >= maxX) { x = maxX; vx = -vx * WALL_BOUNCE; }

      if (y <= minY) { y = minY; vy = -vy * BOUNCE; }
      if (y >= maxY) { y = maxY; vy = -vy * BOUNCE; vx *= 0.98; }

      vx *= AIR_FRICTION;
      vy *= AIR_FRICTION;

      el.style.left = x + "px";
      el.style.top  = y + "px";

      // ì´ëª¨ì§€ë³„ ì”ìƒ
      trailUpdate(el, x, y);

      if (Math.abs(vx) < STOP_V && Math.abs(vy) < STOP_V && y >= maxY - 1) {
        el.classList.remove("flying");
        fallToGround(el);
        trailStop(el);
        stopFlight(el);
        return;
      }

      const raf = requestAnimationFrame(step);
      flights.set(el, raf);
    };

    const raf = requestAnimationFrame(step);
    flights.set(el, raf);
  }

  // ë¹„ìš°ê¸°
  if (cleanBtn) {
    cleanBtn.addEventListener("click", () => {
      document.querySelectorAll(".emoji-sticker").forEach(el => el.remove());
      trailStopAll();
      Array.from(flights.keys()).forEach(stopFlight);
    });
  }

  // ë“œë˜ê·¸ + ë†“ìœ¼ë©´(groundedë©´) ë‚ ì•„ê°€ê¸°
  let draggingEl = null;
  let offsetX = 0;
  let offsetY = 0;

  let lastMoveT = 0;
  let lastMoveX = 0;
  let lastMoveY = 0;
  let velX = 0;
  let velY = 0;

  document.addEventListener("pointerdown", (e) => {
    const t = e.target;
    if (!(t instanceof Element)) return;
    if (!t.classList.contains("emoji-sticker")) return;

    draggingEl = t;
    stopFlight(draggingEl);

    const left = parseFloat(draggingEl.style.left) || 0;
    const top  = parseFloat(draggingEl.style.top)  || 0;

    offsetX = e.clientX - left;
    offsetY = e.clientY - top;

    lastMoveT = performance.now();
    lastMoveX = left;
    lastMoveY = top;
    velX = 0; velY = 0;

    if (draggingEl.classList.contains("grounded")) {
      draggingEl.classList.add("dragging");
      trailStart(draggingEl);
      trailUpdate(draggingEl, left, top);
    }

    draggingEl.setPointerCapture(e.pointerId);
  });

  document.addEventListener("pointermove", (e) => {
    if (!draggingEl) return;

    let x = e.clientX - offsetX;
    let y = e.clientY - offsetY;

    const pad = 10;
    x = Math.max(pad, Math.min(window.innerWidth  - pad, x));
    y = Math.max(pad, clampToGround(draggingEl, y));

    draggingEl.style.left = x + "px";
    draggingEl.style.top  = y + "px";

    const now = performance.now();
    const dt = Math.max(0.001, (now - lastMoveT) / 1000);
    velX = (x - lastMoveX) / dt;
    velY = (y - lastMoveY) / dt;
    lastMoveT = now;
    lastMoveX = x;
    lastMoveY = y;

    if (draggingEl.classList.contains("grounded")) {
      trailUpdate(draggingEl, x, y);
    }
  });

  document.addEventListener("pointerup", () => {
    if (!draggingEl) return;

    if (document.body.contains(draggingEl) && draggingEl.classList.contains("grounded")) {
      draggingEl.classList.remove("dragging");
      startFlight(draggingEl, velX, velY);
      draggingEl = null;
      return;
    }

    tryMerge(draggingEl);
    draggingEl = null;
  });

  document.addEventListener("pointercancel", () => {
    if (!draggingEl) return;

    if (draggingEl.classList.contains("grounded")) {
      draggingEl.classList.remove("dragging");
      fallToGround(draggingEl);
      trailStop(draggingEl);
    }

    draggingEl = null;
  });

})();
</script>

